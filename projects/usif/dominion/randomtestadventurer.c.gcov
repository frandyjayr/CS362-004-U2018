        -:    0:Source:randomtestadventurer.c
        -:    0:Graph:randomtestadventurer.gcno
        -:    0:Data:randomtestadventurer.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <time.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <math.h>
        -:    5:#include <string.h>
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:
        -:    9:#define MAX_TESTS 5
        -:   10:
        -:   11:enum Fails {cardEffectFail = 0, shuffleFail, drawCardFail, handCountFail, deckCountFail, treasureCountFail};  
        -:   12: 
        -:   13:// The following program executes random tests for the Adventurercard
        -:   14:
     9000:   15:void randomizeGameState(struct gameState* G, int* p) {
     9000:   16:	int money[] = {copper, silver, gold};
        -:   17:	// The following code was taken from CS362 Lecture
        -:   18:	int i;
236709000:   19:	for (i = 0; i < sizeof(struct gameState); i++) {
236700000:   20:		((char*)G)[i] = rand() % 256 + 1;
        -:   21:	}
     9000:   22:	*p = rand() % (MAX_PLAYERS);
     9000:   23:	G->numPlayers = *p;
     9000:   24:	G->playedCardCount = rand() % MAX_DECK;
     9000:   25:	G->deckCount[*p] = rand() % (MAX_DECK + 1 - 3) + 3;
     9000:   26:	G->discardCount[*p] = 0;
     9000:   27:	G->handCount[*p] = rand() % (MAX_HAND + 1) ;
     9000:   28:	G->whoseTurn = *p;
        -:   29:
     9000:   30:	int deckMax = G->deckCount[*p];
     9000:   31:	int randomTreasurers = rand() % (deckMax + 1 - 3) + 3;
        -:   32:	// Put only treasure cards in the deck with a random amount
        -:   33:	 
  1134919:   34:	for (i = 0; i < randomTreasurers; i++) {	
  1125919:   35:		G->deck[*p][i] = money[rand() % 3]; 
        -:   36:	}
     9000:   37:}
        -:   38:
     9000:   39:void testAdventurerCard(struct gameState* post, int* failedTests, int* passedTests, int* p) {
        -:   40:	struct gameState pre;
     9000:   41:	memcpy(&pre, post, sizeof(struct gameState));
        -:   42:
     9000:   43:	int choice1 = 0,
     9000:   44:	    choice2 = 0,
     9000:   45:	    choice3 = 0; 
     9000:   46:	int card = adventurer;
     9000:   47:	int bonus = 0;
     9000:   48:	int handPos = 0;
     9000:   49:	int z = 0;
     9000:   50:	int drawntreasure = 0;
     9000:   51:	int cardDrawn = -1;
        -:   52:	int temphand[MAX_HAND]; 
     9000:   53:	int shuffleAmount = 0;
     9000:   54:	int shuffled = 0;
     9000:   55:	int drawCardFailed = 0;
        -:   56:	int status;
        -:   57:
     9000:   58:	if (cardEffect(card, choice1, choice2, choice3, post, handPos, &bonus)) {
    #####:   59:		failedTests[cardEffectFail]++;
        -:   60:	} else {
     9000:   61:		passedTests[cardEffectFail]++;
        -:   62:	}
        -:   63:
        -:   64:	
        -:   65:
  1152993:   66:	while(drawntreasure<2){
  1134993:   67:		if (pre.deckCount[*p] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####:   68:	  		if (shuffle(*p, &pre) == 0) {
    #####:   69:				shuffled = 1;
    #####:   70:				shuffleAmount++;	
        -:   71:			}
        -:   72:		}
        -:   73:
  1134993:   74:		status = drawCard(*p, &pre);
  1134993:   75:		if (status) {
    #####:   76:			drawCardFailed = 1;
        -:   77:		} 
  1134993:   78:		cardDrawn = pre.hand[*p][pre.handCount[*p]-1];//top card of hand is most recently drawn card.
  1134993:   79:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    18000:   80:		  	drawntreasure++;
        -:   81:		else{
  1116993:   82:			temphand[z]=cardDrawn;
  1116993:   83:			pre.handCount[*p]--; //this should just remove the top card (the most recently drawn one).
  1116993:   84:			z++;	
        -:   85:		}
        -:   86:      	}
        -:   87:
  1134993:   88:	while(z-1>=0){
  1116993:   89:		pre.discard[*p][pre.discardCount[*p]++]=temphand[z-1]; // discard all cards in play that have been drawn
  1116993:   90:		z=z-1;
        -:   91:      	}
        -:   92:
        -:   93:	// Check if any shuffle errors occurred 
     9000:   94:	if (shuffleAmount == 0 && shuffled) {
    #####:   95:		failedTests[shuffleFail]++;	
        -:   96:	} else {
     9000:   97:		passedTests[shuffleFail]++;
        -:   98:	}
        -:   99:
        -:  100:	// Check if any drawCard failures occurred
     9000:  101:	if (drawCardFailed) {
    #####:  102:		failedTests[drawCardFail]++;
        -:  103:	} else {
     9000:  104:		passedTests[drawCardFail]++;	
        -:  105:	}
        -:  106:
        -:  107:	// Check if the hand counts match
     9000:  108:	if (pre.handCount[*p] != post->handCount[*p]) {
     9000:  109:		failedTests[handCountFail]++;
        -:  110:	} else {
    #####:  111:		passedTests[handCountFail]++;
        -:  112:	}
        -:  113:	
        -:  114:	// Check if the deck counts match
     9000:  115:	if (pre.deckCount[*p] != post->deckCount[*p]) {
     9000:  116:		failedTests[deckCountFail]++;
        -:  117:	} else {
    #####:  118:		passedTests[deckCountFail]++;
        -:  119:	}	
        -:  120:	
        -:  121:	int i;	
     9000:  122:	int preTreasureCount = 0;
     9000:  123:	int postTreasureCount = 0;
        -:  124:
        -:  125:	// Check if the number of treasures matches
  2269419:  126:	for (i = 0; i < pre.handCount[*p]; i++) {
  2260419:  127:		if (pre.hand[*p][i] == copper || pre.hand[*p][i] == silver || pre.hand[*p][i] == gold) {
    18000:  128:			preTreasureCount++;
        -:  129:		}
        -:  130:	}
  2278419:  131:	for (i = 0; i < post->handCount[*p]; i++) {
  2269419:  132:		if (post->hand[*p][i] == copper || post->hand[*p][i] == silver || post->hand[*p][i] == gold) {
    27000:  133:			postTreasureCount++;
        -:  134:		}
        -:  135:	}
        -:  136:
     9000:  137:	if (preTreasureCount != postTreasureCount) {
     9000:  138:		failedTests[treasureCountFail]++;	
        -:  139:	} else {
    #####:  140:		passedTests[treasureCountFail]++;
        -:  141:	}
        -:  142:
     9000:  143:}
        -:  144:
        1:  145:int main() {
        1:  146:	int iterations = 9000;
        1:  147:	printf("-------------------- TESTING ADVENTURER CARD ---------------------\n");
        1:  148:	printf("NUMBER OF ITERATIONS: %i\n\n", iterations);
        1:  149:	srand(time(NULL));
        1:  150:	int* failedTests = malloc(sizeof(int) *	MAX_TESTS);
        1:  151:	int* passedTests = malloc(sizeof(int) * MAX_TESTS);
        1:  152:	int numberOfFailures = 0;
        -:  153:	int i;
        -:  154:
     9001:  155:	for (int i = 0; i < iterations; i++) {
     9000:  156:		struct gameState *G = malloc(sizeof(struct gameState));
     9000:  157:		int* p = malloc(sizeof(int));
     9000:  158:		randomizeGameState(G,p);
     9000:  159:		testAdventurerCard(G, failedTests, passedTests, p);
     9000:  160:		free(G);
     9000:  161:		free(p);
        -:  162:	}
        -:  163:
        1:  164:	printf("Number of cardEffect() failures: %i\n", failedTests[cardEffectFail]);
        1:  165:	printf("Number of shuffle() failures: %i\n", failedTests[shuffleFail]);
        1:  166:	printf("Number of drawCard() failures: %i\n", failedTests[drawCardFail]);
        1:  167:	printf("Number of handCount failures: %i\n", failedTests[handCountFail]);
        1:  168:	printf("Number of deckCount failures: %i\n", failedTests[deckCountFail]);
        1:  169:	printf("Number of treasureCount failures: %i\n", failedTests[treasureCountFail]);
        1:  170:	printf("\n");
        -:  171:
        1:  172:	printf("Number of cardEffect() passes: %i\n", passedTests[cardEffectFail]);
        1:  173:	printf("Number of shuffle() passes: %i\n", passedTests[shuffleFail]);
        1:  174:	printf("Number of drawCard() passes: %i\n", passedTests[drawCardFail]);
        1:  175:	printf("Number of handCount passes: %i\n", passedTests[handCountFail]);
        1:  176:	printf("Number of deckCount passes: %i\n", passedTests[deckCountFail]);
        1:  177:	printf("Number of treasureCount passes: %i\n", passedTests[treasureCountFail]);
        1:  178:	printf("\n");
        -:  179:
        6:  180:	for (i = 0; i < MAX_TESTS; i++) {
        5:  181:		numberOfFailures = numberOfFailures + failedTests[i];
        -:  182:	}
        -:  183:
        1:  184:	if (numberOfFailures == 0) {
    #####:  185:		printf("RANDOM TESTS SUCCESSFULL!\n");
        -:  186:	} else {
        1:  187:		printf("RANDOM TESTS FAILURE!\n");	
        -:  188:	}
        1:  189:	return 0;	
        -:  190:	
        -:  191:}
